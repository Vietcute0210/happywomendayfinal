<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>L·ªùi ch√∫c 3D</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(
          ellipse at center,
          #000011 0%,
          #000000 100%
        );
        font-family: "Times New Roman", Times, serif;
        user-select: none;
        perspective: 1000px;
        cursor: pointer;
      }
      #galaxy,
      #rotatingContainer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }
      /* Allow the rotating container to receive pointer events so we can drag */
      #rotatingContainer {
        z-index: 2;
        top: 50%;
        left: 50%;
        transform-style: preserve-3d;
        transform-origin: center center;
        transform: translate(-50%, -50%) rotateX(0deg) rotateY(0deg);
        touch-action: none;
        cursor: grab;
        /* pointer-events default (auto) allows pointerdown/drag */
      }
      .text-particle,
      .image-particle {
        position: absolute;
        will-change: transform, opacity;
        user-select: none;
        pointer-events: none;
      }

      .text-particle {
        white-space: nowrap;
        text-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        color: #ff7487;
      }
      .image-particle {
        /* Increase the maximum dimensions of image particles further so they
         appear more prominent in the 3D message space. A larger size of
         approximately 140px makes the photos easier to see while still
         fitting comfortably in the 3D environment. */
        max-width: 140px;
        max-height: 140px;
        border-radius: 8px;
        filter: drop-shadow(0 0 5px #fff);
      }
    </style>
  </head>
  <body>
    <div id="galaxy"></div>
    <div id="rotatingContainer"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
      // Retrieve customization from window.name or localStorage
      function getCustom() {
        try {
          if (window.name) {
            const obj = JSON.parse(window.name);
            return obj || {};
          }
        } catch {}
        try {
          const raw = localStorage.getItem("customization");
          if (raw) {
            return JSON.parse(raw);
          }
        } catch {}
        return {};
      }
      const custom = getCustom();

      // Provide a default list of images/GIFs if customization does not specify any
      const defaultImages = [
        "giftbox.png",
        "heartAnimation.gif",
        "mewmew.gif",
        "9313a43c-9a60-4469-ac4f-6d841d24e9a7.png",
        "35da2b21-3388-4959-af82-f97a0b2b15e7.png",
        "015b3851-f504-4ebe-9c62-d0970e8e1fa3.png",
        "ee27448f-01b1-4252-8f45-d054a6763a49.png",
      ];

      // Determine messages and images from customization
      const messages =
        Array.isArray(custom.messages) && custom.messages.length
          ? custom.messages
          : ["You are my sunshine üåü", "Always be happy", "With love"];
      const imageURLs =
        Array.isArray(custom.imgs) && custom.imgs.length
          ? custom.imgs
          : defaultImages;

      // Icons (hearts)
      const icons = ["‚ù§Ô∏è", "üíó", "üíï"];
      const imageIcons = [
        "giftbox.png",
        "heartAnimation.gif",
        "mewmew.gif",
        "be6672ed-5fd6-42ac-98fb-2f902345cbd9.png",
        "9313a43c-9a60-4469-ac4f-6d841d24e9a7.png",
        "35da2b21-3388-4959-af82-f97a0b2b15e7.png",
        "015b3851-f504-4ebe-9c62-d0970e8e1fa3.png",
        "ee27448f-01b1-4252-8f45-d054a6763a49.png",
      ];

      const maxParticles = 120;
      const activeParticles = new Set();

      const rotatingContainer = document.getElementById("rotatingContainer");
      const galaxy = document.getElementById("galaxy");

      function createParticle(type = "text") {
        if (activeParticles.size >= maxParticles) return;
        const el =
          type === "text"
            ? document.createElement("div")
            : document.createElement("img");
        if (type === "text") {
          const isIcon = Math.random() < 0.3;
          el.className = "text-particle";
          if (isIcon) {
            // ch·ªçn emoji ho·∫∑c ·∫£nh ng·∫´u nhi√™n
            if (Math.random() < 0.5) {
              // emoji
              el.textContent = icons[Math.floor(Math.random() * icons.length)];
              el.style.fontSize = 20 + Math.random() * 10 + "px";
            } else {
              // ·∫£nh icon
              const img = document.createElement("img");
              img.src =
                imageIcons[Math.floor(Math.random() * imageIcons.length)];
              img.className = "image-particle";
              el.appendChild(img);
            }
          } else {
            el.textContent =
              messages[Math.floor(Math.random() * messages.length)];
            el.style.fontSize = 18 + Math.random() * 10 + "px";
          }
        } else {
          if (imageURLs.length === 0) return;
          el.className = "image-particle";
          el.src = imageURLs[Math.floor(Math.random() * imageURLs.length)];
        }
        el.style.opacity = 0;
        rotatingContainer.appendChild(el);
        const w = el.offsetWidth || 40;
        el.style.left = Math.random() * (window.innerWidth - w) + "px";
        const z = -Math.random() * 300;
        const startY = -50;
        const endY = window.innerHeight + 50;
        const duration = 7000 + Math.random() * 4000;
        const t0 = performance.now();
        function animate(t) {
          const p = (t - t0) / duration;
          if (p >= 1) {
            el.remove();
            activeParticles.delete(el);
          } else {
            const y = startY + p * (endY - startY);
            const op = p < 0.1 ? p * 10 : p > 0.9 ? (1 - p) * 10 : 1;
            el.style.opacity = op;
            el.style.transform = `translate3d(0, ${y}px, ${z}px)`;
            requestAnimationFrame(animate);
          }
        }
        activeParticles.add(el);
        requestAnimationFrame(animate);
      }

      function loopParticles() {
        let last = 0;
        function tick(t) {
          if (t - last > 300) {
            createParticle("text");
            if (Math.random() < 0.5) createParticle("image");
            last = t;
          }
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }

      function startStars() {
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 150;
        const renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        galaxy.appendChild(renderer.domElement);
        const starsCount = 500;
        const positions = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 400;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        const starTexture = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/sprites/disc.png"
        );
        const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.5,
          map: starTexture,
          transparent: true,
          alphaTest: 0.2,
          depthWrite: false,
        });
        const stars = new THREE.Points(geometry, material);
        scene.add(stars);
        function animate() {
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      // Replace initRotation with pointer-drag based rotation that accumulates
      function initRotation() {
        let pointerDown = false;
        let lastX = 0,
          lastY = 0;
        let rotX = 0,
          rotY = 0;
        let activePointerId = null;

        // Maintain a quaternion representing the current orientation to avoid gimbal lock.
        let orientation = { x: 0, y: 0, z: 0, w: 1 };
        function quatMultiply(a, b) {
          return {
            w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
            x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
            z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,
          };
        }
        function quatNormalize(q) {
          const len = Math.sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z);
          return { x: q.x / len, y: q.y / len, z: q.z / len, w: q.w / len };
        }
        function quatFromAxisAngle(axis, angle) {
          const half = angle / 2;
          const s = Math.sin(half);
          return {
            x: axis[0] * s,
            y: axis[1] * s,
            z: axis[2] * s,
            w: Math.cos(half),
          };
        }
        function quatToMatrix4(q) {
          const x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
          const xx = x * x,
            yy = y * y,
            zz = z * z;
          const xy = x * y,
            xz = x * z,
            yz = y * z;
          const wx = w * x,
            wy = w * y,
            wz = w * z;
          return [
            1 - 2 * (yy + zz),
            2 * (xy - wz),
            2 * (xz + wy),
            0,
            2 * (xy + wz),
            1 - 2 * (xx + zz),
            2 * (yz - wx),
            0,
            2 * (xz - wy),
            2 * (yz + wx),
            1 - 2 * (xx + yy),
            0,
            0,
            0,
            0,
            1,
          ];
        }

        function setRotation(dx, dy) {
          // Convert pixel movement into small rotation increments (radians).
          const yaw = dx * 0.005; // rotation around Y-axis for horizontal drag
          const pitch = -dy * 0.005; // rotation around X-axis for vertical drag
          // Create quaternions representing the yaw and pitch rotations.
          const qYaw = quatFromAxisAngle([0, 1, 0], yaw);
          const qPitch = quatFromAxisAngle([1, 0, 0], pitch);
          // Apply the incremental rotations to the current orientation.
          orientation = quatMultiply(qYaw, orientation);
          orientation = quatMultiply(qPitch, orientation);
          orientation = quatNormalize(orientation);
          // Convert orientation to a 4x4 rotation matrix and apply as a CSS transform.
          const m = quatToMatrix4(orientation);
          rotatingContainer.style.transform = `translate(-50%, -50%) matrix3d(${m.join(
            ","
          )})`;
        }
        function updateCursor(isActive) {
          rotatingContainer.style.cursor = isActive ? "grabbing" : "grab";
        }
        function releasePointerCapture() {
          if (activePointerId !== null) {
            try {
              rotatingContainer.releasePointerCapture(activePointerId);
            } catch {
              /* ignored */
            }
          }
        }
        function endInteraction() {
          pointerDown = false;
          updateCursor(false);
          releasePointerCapture();
          activePointerId = null;
        }
        function onPointerDown(e) {
          // If the previous drag was not ended properly (e.g. missed pointerup), force
          // ending the interaction so the next drag can start cleanly.
          if (pointerDown) {
            endInteraction();
          }
          pointerDown = true;
          activePointerId = e.pointerId;
          lastX = e.clientX;
          lastY = e.clientY;
          updateCursor(true);
          try {
            rotatingContainer.setPointerCapture(activePointerId);
          } catch {
            /* ignored */
          }
        }
        function onPointerMove(e) {
          if (!pointerDown || e.pointerId !== activePointerId) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          setRotation(dx, dy);
          lastX = e.clientX;
          lastY = e.clientY;
        }
        function onPointerUp(e) {
          if (e.pointerId !== activePointerId) return;
          endInteraction();
        }
        function onPointerCancel(e) {
          if (e.pointerId !== activePointerId) return;
          endInteraction();
        }
        rotatingContainer.addEventListener("pointerdown", onPointerDown);
        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", onPointerUp);
        window.addEventListener("pointercancel", onPointerCancel);
        rotatingContainer.addEventListener(
          "lostpointercapture",
          endInteraction
        );
        // Prevent default dragging on images inside the container
        document.querySelectorAll("img").forEach((img) => {
          img.addEventListener("dragstart", (e) => e.preventDefault());
        });
      }

      // Setup music with default fallback and infinite loop
      function setupMusic() {
        const audio = document.createElement("audio");
        audio.id = "messageAudio";
        audio.controls = true;
        audio.loop = true;
        audio.autoplay = true;
        audio.setAttribute("playsinline", "true");
        audio.setAttribute("webkit-playsinline", "true");
        audio.style.position = "fixed";
        audio.style.bottom = "1rem";
        audio.style.left = "1rem";
        audio.style.zIndex = "10";
        audio.style.opacity = "0.85";

        if (custom.audio) {
          audio.src = custom.audio;
        } else {
          // Default audio file name ‚Äî replace with your own file name (placed in same directory)
          audio.src = "your_song.mp3";
        }
        document.body.appendChild(audio);

        const resumeFromSaved = () => {
          if (
            typeof custom.audioTime === "number" &&
            !Number.isNaN(custom.audioTime)
          ) {
            try {
              audio.currentTime = custom.audioTime;
            } catch {
              /* ignored */
            }
          }
        };
        if (audio.readyState >= 1) {
          resumeFromSaved();
        } else {
          audio.addEventListener("loadedmetadata", resumeFromSaved, {
            once: true,
          });
        }

        const unlockEvents = ["pointerdown", "touchstart", "click", "keydown"];
        function removeUnlock() {
          unlockEvents.forEach((evt) =>
            document.removeEventListener(evt, unlockHandler)
          );
        }
        function unlockHandler() {
          audio
            .play()
            .then(() => removeUnlock())
            .catch(() => {
              // keep listeners so the next interaction can retry
            });
        }

        audio
          .play()
          .then(() => removeUnlock())
          .catch(() => {
            unlockEvents.forEach((evt) =>
              document.addEventListener(evt, unlockHandler, {
                once: true,
                passive: evt === "touchstart",
              })
            );
          });

        function persistAudioTime() {
          try {
            custom.audioTime = audio.currentTime;
            localStorage.setItem("customization", JSON.stringify(custom));
            window.name = JSON.stringify(custom);
          } catch {
            /* ignored */
          }
        }
        window.addEventListener("pagehide", persistAudioTime);
        window.addEventListener("beforeunload", persistAudioTime);
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            persistAudioTime();
          }
        });
      }

      window.addEventListener("DOMContentLoaded", () => {
        startStars();
        loopParticles();
        initRotation();
        setupMusic();
      });
    </script>
  </body>
</html>
